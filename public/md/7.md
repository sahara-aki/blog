
# React Hooks学习
> antd更新了4.0之后, 发现示例都已经是用react hooks来实现的了,看来hooks是大势所趋,学习一下把.

## useState的使用
### 为什么要使用useState
`useState` 的出现是 ： 在函数组件里面使用 class的 `setState`

解决了的问题是：当我们一个函数组件想要有自己维护的state的时候，不得已只能转换成class。这样很麻烦！

使用方法:
```javascript
import React, {useState} from 'react';	
function Counter() {	
  const [	number,	setNumber	] = useState(0)	
  return (	
    <>	
      <p>{number}</p>	
      <button	
        onClick={	
          () => setNumber(number + 1)	
        }	
      >	
        改数字	
      </button>	
    </>	
  )	
}	

ReactDOM.render(<Counter />, document.getElementById('root'));	

```

### useState的坑
`useState的初始值，只在第一次有效`
```javascript
const Child = memo(({data}) =>{
    console.log('child render...', data)
    const [name, setName] = useState(data)
    return (
        <div>
            <div>child</div>
            <div>{name} --- {data}</div>
        </div>
    );
})

const Hook =()=>{
    console.log('Hook render...')
    const [count, setCount] = useState(0)
    const [name, setName] = useState('rose')

    return(
        <div>
            <div>
                {count}
            </div>
            <button onClick={()=>setCount(count+1)}>update count </button>
            <button onClick={()=>setName('jack')}>update name </button>
            <Child data={name}/>
        </div>
    )
}
```

`当点击按钮修改name的值的时候，我发现在Child组件， 是收到了，但是并没有通过useState赋值给name！`

## useEffect使用指南
### useEffect的用途
useEffect用于处理组件中的effect，通常用于`请求数据`，`事件处理`，`订阅`等相关操作。这里以数据请求为例，来深入介绍useEffect的用法。

用户场景:进入页面进行请求,获取数据,渲染到页面上

为了获取后端提供的数据，接下来将使用axios来发起请求，同样也可以使用fetch，这里会使用useEffect来进行操作。

```javascript
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function App() {
  const [data, setData] = useState([]);

  useEffect(async () => {
    const res = await axios(
      'http://xxxx请求地址',
    );
    setData(res.data);
  });

  return (
    <ul>
      {data.map((item,index) => (
        <li key={index}>
          {item.content}
        </li>
      ))}
    </ul>
  );
}

export default App;
```

### useEffect的坑
1.在useEffect中，不仅会请求后端的数据，还会通过调用setData来更新本地的状态，这样会触发view的更新。

所以，运行这个程序的时候，会出现`无限循环`的情况。useEffect在组件`mount时执行`，但也会在`组件更新时执行`。因为我们在每次请求数据之后都会设置本地的状态，所以组件会更新，因此useEffect会再次执行，因此出现了`无限循环`的情况。

我们只想在组件didmount时请求数据。我们可以`传递一个空数组作为useEffect的第二个参数`，这样就能`避免在组件更新执行useEffect`，只会在组件didmount时执行。

```javascript
  useEffect(async () => {
    const res = await axios(
      'http://xxxx请求地址',
    );
    setData(res.data);
  },[]);

```

2.在代码中，我们使用async / await从第三方API获取数据。如果你对async/await熟悉的话，你会知道，`每个async函数都会默认返回一个隐式的promise`。但是，useEffect不应该返回任何内容。这就是为什么会在控制台日志中看到以下警告：

>Warning: useEffect function must return a cleanup function or nothing. Promises and useEffect(async () => …) are not supported, but you can call an async function inside an effect

这就是为什么不能直接在useEffect中使用async函数，因此，我们可以`不直接调用async函数`，而是像下面这样：

```javascript
 useEffect(() => {
    const fetchData = async () => {
      const result = await axios(
        'http://localhost/api/v1/search?query=redux',
      );

      setData(result.data);
    };

    fetchData();
  }, []);
```

3.在上面的例子中,实现了在didmount中进行请求,在有的情况下,比如需要模糊查询,需要相应用户的输入来进行请求

业务场景:引入一个Input框,监听value值的变化

```javascript
import axios from 'axios';

function App() {
  const [data, setData] = useState([]);
  const [value, setValue] = useState('');

  useEffect(() => {
    const fetchData = async () => {
      const result = await axios(
        'http://localhost/api/v1/search?query=redux',
      );
      setData(result.data);
    };
    fetchData();
  }, [value]);

  return (
    <Fragment>
      <input
        type="text"
        value={value}
        onChange={e => setValue(e.target.value)}
      />
      <ul>
        {data.hits.map(item => (
          <li key={item.objectID}>
            <a href={item.url}>{item.title}</a>
          </li>
        ))}
      </ul>
    </Fragment>
  );
}

export default App;
```
前面我们说了，目前的useEffect只会在did组件mount时执行，并且useEffect的第二个参数是依赖的变量，一旦这个依赖的变量变动，useEffect就会重新执行，前面传的是[],所以只执行一次,所以这次我们需要添加value为useEffect的依赖,这样就可以实现根据state的变化来进行操作.

一旦更改了query值，就可以重新获取数据。但这会带来另一个问题：query的任何一次变动都会请求后端，这样会带来比较大的访问压力。这个时候我们需要引入一个按钮，点击这个按钮再发起请求,点击按钮的时候,赋值给一个state,然后useEffect来绑定这个state来进行操作

```javascript
import axios from 'axios';

function App() {
  const [data, setData] = useState([]);
  const [value, setValue] = useState('');
  const [search, setSearch] = useState('');

  useEffect(() => {
    const fetchData = async () => {
      const result = await axios(
        'http://localhost/api/v1/search?query=redux',
      );
      setData(result.data);
    };
    fetchData();
  }, [search]);

  return (
    <Fragment>
      <input
        type="text"
        value={value}
        onChange={e => setValue(e.target.value)}
      />
      <button onClick={()=>setSearch(value)}>查询</button>
      <ul>
        {data.hits.map(item => (
          <li key={item.objectID}>
            <a href={item.url}>{item.title}</a>
          </li>
        ))}
      </ul>
    </Fragment>
  );
}

export default App;

```
